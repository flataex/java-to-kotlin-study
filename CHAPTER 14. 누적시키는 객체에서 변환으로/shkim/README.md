가변 상태를 공유해 계산을 수행하면 책임이 여러 클래스에 지저분하게 분산되는 경우가 흔하다. <br>
코틀린에서는 기능을 객체로 표현하지 않고 함수로 표현한다. (가변 클래스 -> 불변 데이터에 작용하는 함수)

### 가변 상태에 의존하는 계산을 불변 데이터를 변환해 수행하는 계산으로 리팩토링 순서는

1. 가변 클래스를 사용하는 함수/클래스에서 불변 값 타입을 다루는 것 처럼 변경한다. (오버로딩, 부생성자 등을 사용할 수 있다)
2. 가변 클래스를 불변 데이터 클래스로 변경한다.

이 과정에서, 컬렉션과 필드를 변이시키는 명령형 코드를 groupingBy, fold, reduce 등의 표준 고차 함수를 호출하도록 변경한다. <br>
이런 함수들은 내부적으로 상태를 바꿀 수도 있지만, 호출하는 쪽에서는 그 상태 변이를 볼 수 없다. (이런 고차 함수들은 계산이다)

**직접 상태를 변이시키지 말고, 표준 라이브러리의 고차 함수를 사용하자.**