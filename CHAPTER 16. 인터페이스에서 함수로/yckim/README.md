# 인터페이스에서 함수로

- 자바에서는 기능을 정의하는 코드와 기능이 필요한 코드 사이에 계약을 지정하기 위해 인터페이스를 사용합니다.
    - 인터페이스는 계약의 두 당사자를 서로 결합하기 때문에 소프트웨어가 더 유지보수 하기 어려워집니다.

## 객체지향 캡슐화
- 객체지향언어에서는 객체가 데이터를 캡슐화하고 있기 때문에 별도의 세부 데이터들을 메서드에 전달할 필요가 없습니다.
    - 관련한 데이터는 프로퍼티로 관리하고 그에 대한 동작은 메서드를 사용하는 방식을 많이 사용합니다.
- 메서드를 구현 클래스에 의존하지 않고 인터페이스에서 의존한다면 다음과 같은 장점을 얻을 수도 있습니다.
    - 테스트 코드를 통해 가짜 메서드를 사용할 수 있으므로 테스트에 용이해집니다.
    - 다양한 구현체를 사용할 수 있으므로 다형성을 활용할 수 있습니다.
- 클라이언트는 사용 지점에서 세부 설정을 제공해야만 하는 문제로부터 자유로워지며, 구현자는 사용자와 별도로 구현을 개선할 수 있게 됩니다.
- 클로저를 사용하면 해당 클래스를 다시 다운캐스팅하여 메서드를 호출하게 하는 등의 동작을 막을 수 있습니다.
    - 코틀린 1.4에서부터 fun interface로 정의하면 메서드가 하나뿐인 객체를 선언하는 대신에 람다를 사용해 인터페이스의 유일한 연산을 정의할 수 있습니다.

## 함수형 캡슐화
- 함수형 프로그래밍에서는 부분적용을 통해 세부 기능 전달을 진행합니다.
- 부분 적용은 함수의 인자 중 일부를 고정시키면서 인자가 더 적은 새 함수를 만들어내는 기법입니다.

    ```kotlin
    // 설정을 알 수 있는 곳
    val sender: (Email) -> Unit = createEmailSender(
    	inetAddress("smtp.travelator.com"),
    	"username",
    	"password"
    )
    
    // 메시지를 보내는 곳
    fun sendThanks() {
    	sender(
    		Email(
    			to = parse("support@internationalrescue.org"),
    			from = parse("support@travelator.com"),
    			subject = "Thanks for your help",
    			body = "..."
    		)
    	)
    }
    ```
## 자바의 함수 타입
- 객체 지향과 함수형 형태 모두 원하는 것을 전달하는 것을 캡슐화할 수 있게 해줍니다.
    - 어떤 데이터 구조든 이런일을 할 수 있지만 객체와 함수는 실행될 수 있는 연산을 제공하기 때문에 클라이언트가 상세한 정보를 인식하지 않고 최소한의 정보만 전달할 수 있습니다.
- 함수적 해법과 객체지향 해법을 하나로 합치는 한 가지 방법은 함수를 오직 invoke라는 메서드만 제공하는 객체로 간주하는 것입니다.
- 함수 타입을 가리키기 위해 자바는 원하는 시그니처의 단일 추상 메서드(SAM, Single Abstract Method) 인터페이스를 사용합니다.
- 코틀린 런타임은 자체적인 함수 타입을 사용해서 컴파일러가 (TYPE) → Unit 을 Function1<TYPE, Unit> 타입으로 컴파일합니다.
    - 파라미터 갯수에 따라 코틀린 FunctionN 인터페이스가 수 없이 존재합니다.
## 믹스 앤드 매치
- 자바와 코틀린에서 함수타입은 인터페이스입니다.
- 코틀린은 함수 파라미터에 이름을 붙여 표현력을 더 높일 수 있습니다.

    ```kotlin
    (toSend: Email) -> Unit
    ```

- 함수 타입이 표현력이 충분하지 않다면 타입 별명을 통해 표현력을 높일 수 있습니다.

    ```kotlin
    typealias EmailSenderFunction = (Email) -> Unit
    ```
## 여러 접근 방법의 비교
- 객체지향 접근 방법은 타입을 정의하고 메서드를 정의합니다.

    ```kotlin
    class EmailSender(
    	private val serverAddress: InetAddress,
    	private val username: String,
    	private val password: String
    ) {
    	fun send(email: Email) {
    		sendEmail(
    			email,
    			serverAddress,
    			username,
    			password
    		)
    	}
    }
    ```

- 함수형 접근 방식은 타입을 정의할 필요가 없고 바로 함수를 선언합니다.

    ```kotlin
    // 설정을 알 수 있는 곳
    val sender: (Email) -> Unit = createEmailSender(
    	...
    )
    
    // 메시지를 보내는 곳
    fun sendThanks() {
    	send(
    		Email(
    			...
    		)
    	)
    }
    ```

- 인터페이스를 활용하여 여러 기능을 포함하는 맵을 전달할 수 있습니다.

    ```kotlin
    class EmailSystem(
    	val send: (Email) -> Unit,
    	val delete: (Email) -> Unit,
    	val list: (folder: Folder) -> List<Email>,
    	val move: (email: Emai,l, to: Folder) -> Unit
    )
    
    fun sendThanks(sender: EmailSystem) {
    	sender.send(
    		Email(
    			...
    		)
    	)
    }
    ```
## 결합
- 의존관계를 인터페이스로 표현하는 방법과 함수 타입을 전달하는 방법의 차이는 클라이언트와 구현 사이의 결합에 있습니다.
- 인터페이스의 경우 다른 어딘가에 구현체가 정의되어 있어야 하며, 결국 클라이언트가 구현에 의존하기 때문에 순환적인 의존성이 생길 수 있습니다.
    - 따라서 인터페이스는 구현과 함께 정의되거나 구현과 클라이언트가 동시에 의존하는 별도의 장소에 정의해야 합니다.
    - 클라이언트와 구현이 인터페이스에 따라 결합되기 때문에 시스템에 대한 리팩터링과 추론이 더 힘들어질 수 있습니다.
- 함수형의 경우 런타임이 모든 함수 타입을 정의하므로 클라이언트와 구현 사이의 컴파일 시점 의존성이 생기지 않습니다.
    - 물론, 실행 시점 의존성은 존재합니다.
    - 의존 관계가 만들어지는 장소에서는 함수의 생성자 코드를 볼 수 있어야 하며, 클라이언트 구현 코드를 호출할 수 있어야 합니다.
    - 예를 들어, 의존관계를 함수 타입으로 표현한 경우 단순히 메서드 참조만 변경하면 되고 사용하는 구현체의 내부는 아무 영향을 받지 않습니다.
- 함수 타입을 사용하면 쉽게 불안정해지는 인터페이스를 안정한 인터페이스로 만들 수 있고, 시스템의 각 부분들을 다른 속도로 진화할 수 있습니다.
## 객체지향인가 함수형인가
- 클라이언트 코드와 특정 구현이 결합되지 않고 다음과 같은 조건을 만족하는 함수라면 함수형으로 작성해도 문제 없습니다.
    - 일반적인 함수
    - 함수 타입을 구현한 객체
    - 클라이언트가 요구하는 시그니처와 같은 타입의 메서드에 대한 참조
    - 클라이언트가 요구하는 시그니처와 같은 타입의 람다
- 함수 타입만으로 충분한 경우, 불필요하게 클라이언트와 이 인터페이스를 결합시켜서는 안됩니다.
    - 구현 하려는 내용보다 더 큰 인터페이스에 의존하면 우리에게 필요한 연산이 무엇인지 명확히 의사소통할 수 있는 기회가 사라지고, 클라이언트가 어쩔 수 없이 모든 인터페이스를 구현하게 됩니다.
- 요구사항을 함수 타입으로 표현하는 쪽을 디폴트로 택하고, 함수를 사용하는게 너무 힘들어지면 그때 클래스로 전환해야 합니다.
## 자바의 레거시
- 레거시 자바 코드는 보통 하위 시스템으로 의존관계를 묶고 싶을때 사용하는 다중 메서드 인터페이스를 사용해 의존관계를 표현했습니다.
    - 심지어 이런 메서드 중 단 하나만 기능을 구현하는 경우에도 다중 메서드 인터페이스를 사용하는 경우가 있었습니다.
    - 이로 인해 결합 문제가 발생하게 되었습니다.
- 코드 기반에 목 프레임워크를 하나 도입하고 나면, 이들이 사용하지 않는 메서드의 구현을 생성하거나 외부 시스템과의 상호 작용을 흉내내는 스텁을 생성하는 문제를 우리 대신 해결해 줍니다.
## 추적 가능성
- 함수를 전달하게 되면 전달하게되는 함수를 추적하기 어렵게 바뀝니다.
- 캡슐화하지 않은 해법을 사용하는 것과 같이 결합을 없애고 일반성을 얻기 위해서는 도구와 개발자들이 분석할 만한 문맥이 줄어든다는 비용을 지불해야 합니다.
- 추적 가능성을 높이기 위해 함수 타입을 초기화한 위치에서 너무 먼 곳 까지 전달하지 않음으로써 도움을 제공할 수 있습니다.
## 인터페이스에서 함수로 리팩터링하기
- 객체지향에서 설정과 구현을 클래스 안에 감추고 치환할 수 있는 기능을 인터페이스로 표현합니다.
- 함수형 프로그래밍에서는 함수가 두 역할을 한꺼번에 담당합니다.
- 함수를 이용하면 자체 인터페이스를 사용하는 것보다 결합을 줄일 수 있어 함수를 디폴트 접근 방법으로 택하는 것을 추천합니다.