# 스트림에서 이터러블이나 시퀀스로

## 자바 스트림
- 자바 8 이후에 등장한 람다식과 스트림을 통해 반복된 작업을 스트림으로 구현할 수 있습니다.
    - for 루프를 실행하면서 이 코드가 하는 일을 생각하기보다 선언된 알고리즘의 각 단계를 한줄 한줄 볼 수 있고, 런타임이 각 단계를 구현하는 데 의존할 수 있습니다.
    - parallelStream을 통해 쉽게 병렬 처리를 하도록 지정할 수 있습니다.
- 자바 스트림은 지연 계산을 수행하며 뒤쪽 파이프라인 단계가 앞쪽 단계에서 수행해야 하는 작업을 제한합니다.
- 자바 9에서는 dropWhile과 takeWhile을 통해 최소한의 동작만 하도록 구현할 수 있습니다.
- 스트림은 대규모 데이터 처리에 특화되어 있고 컬렉션이 작은 경우 속도가 다른 방법에 비해 느립니다.
    - 자바 스트림이 일반적인 컬렉션 변환, 지연 계산, 병렬 처리 등의 작업을 모두 염두에 두고 설계됐는데 이런 작업의 요구 조건이 모두 다르다는 점에 있습니다.
- 코틀린은 병렬 연산을 구현려고 시도하지 않고 두 가지 추상화만 제공합니다.
    - 컬렉션 변환과 축약에 유용한 이터러블
    - 지연 계산을 제공하는 시퀀스

## 코틀린 이터러블
- 코틀린은 컬렉션 연산을 정의하기 위해 새로운 인터페이스를 정의하는 대신 Iterable에 대한 확장 함수를 제공합니다.
- 코틀린 filter, map은 List를 반환합니다
    - 리스트가 계속해서 생성되게 되고 이로인해 리스트에 채워넣는 시간과 메모리가 추가되어 성능이 저하될 수 있습니다.
- 자바에서는 래퍼클래스와 기본형 타입이 존재하므로 박싱 비용이 발생하는데 이를 해결하기 위해 기본형 스트림을 사용합니다.
- 이러한 성능을 너무 신경쓸 필요는 없으며, 코틀린은 컬렉션 크기가 크지 않다면 빠르게 동작합니다.
    - 만약, 컬렉션이 크다면 코틀린에서는 시퀀스로 전환하는 것이 좋습니다.
## 코틀린 시퀀스
- 코틀린의 시퀀스 추상화는 자바 스트림과 같은 지연 연산을 제공합니다.
- Collection, Iterable, Iterator를 Sequence로 변환할 수 있습니다.
    - asSequence()를 사용하면 시퀀스로 사용할 수 있습니다.
- Iterable과 Sequence는 서로의 기능을 거의 지원하기 때문에 코드를 거의 바꾸지 않아도 쉽게 변경할 수 있습니다.
- 시퀀스는 각 단계를 저장하기 위한 중간 리스트 생성 비용이 들지 않습니다.
    - 만약, 원소 개수가 적다면 파이프라인을 만들고 실행하는 비용이 더 클 수 있습니다.
- 박싱 연산을 피하기 위해 다음과 같이 기본타입을 반환하는 함수를 파라미터로 받도록 구현할 수 있습니다.

    ```kotlin
    fun averageNonBlankLength(strings: List<String>): Double =
    	(strings
    		.asSequence()
    		.filter { it.isNotBlank() }
    		.sumBy(String::length) / strings.size.toDouble()
    ```
## 다중 이터레이션
- 자바의 Stream은 최종 연산을 통해 모든 원소를 소비하면 다시 사용할 수 없습니다.

    ```java
    public static double averageNonBlankLength(List<String> strings) {
    	return averageNonBlankLength(strings.stream())
    }
    
    public static double averageNonBlankLength(Stream<String> strings) {
    	return strings
    		.filter(s -> !s.isBlank())
    		.mapToInt(String::length)
    		.sum() / (double) strings.count();
    }
    ```

  위의 코드는 에러를 발생시킵니다.
  `java.lang. IllegalStateException: stream has already been operated upon or closed`

- 코틀린의 시퀀스로는 다음 구문을 실행시키더라도 잘 실행되는 것을 확인할 수 있습니다.

    ```kotlin
    fun averageNonBlankLength(strings: List<String>): Double =
    	averageNonBlankLength(strings.asSequence())
    
    fun averageNonBlankLength(strings: Sequence<String>): Dobule =
    	(strings
    		.filter {it.isNotBlank() }
    		.sumBy(String::length) /strings.count().toDouble()
    ```

- 하지만 코틀린의 시퀀스도 항상 안전한 것은 아닙니다. (예를 들어 메모리에 저장된 컬렉션에 따라 뒷받침되는 컬렉션의 따라 뒷받침되는 시퀀스의 경우 여러 번 이터레이션 해도 안전합니다.)
- Iterator 사용과 같이 한번 소비하면 다시 사용할 수 없는 타입의 경우 예상하지 못한 동작을 막기 위해 IllegalStateException을 던지게 됩니다.
    - 대표적으로 파일이나 네트워크 소켓 등의 외부 자원을 읽어서 처리해야 하는 상황에 이러한 문제가 발생할 수 있습니다. (처음부터 읽기 힘들기 때문에)
    - 시퀀스로 값을 순회하면서 길이를 구하고 싶다면 중간에 count 연산을 넣어 값을 구할 수 있습니다.
- 스트림과 시퀀스의 핵심은 `크기가 정해져 있지 않는 큰 데이터 집합을 다룰 수 있다는 점입니다.`
- 하지만 이런 큰 데이터 집합을 하나하나 세서 전체크기를 알아내는 과정은 그리 효율적이지 못합니다.
    - 그렇기 때문에 시퀀스를 사용할때 여러번 이터레이션 시키는 것은 비효율적입니다.
- 테스트에서 Sequence.constrainOnce()를 이용하면 시퀀스를 처음으로 돌아가서 이터레이션 하는 일을 방지할 수 있습니다.

## 스트림, 이터러블, 시퀀스 사이에 선택하기
- 자바 스트림을 사용하는 코드는 코틀린에서 사용해도 문제없으며, 코틀린의 문법으로 리팩토링 할 수 있습니다.
- 코드가 큰 컬렉션을 처리하고 있으며, 특히 `parallelStream()` 을 사용하고 있다면 스트림을 그대로 둬도 문제 없습니다.
  - 이런 경우 병렬 처리를 JVM이 최적화 해줍니다.
- 코틀린 표준 라이브러리는 스트림을 시퀀스로, 시퀀스를 스트림으로 변환을 지원합니다.
- 코틀린 추상화로 자바 코드를 변환하기로 결정했다면 스트림이 지연 계산의 이점을 활용하고 있느냐에 따라 Iterable과 Sequence 중에 선택할 수 있습니다.
- 지연 계산이 필요한 경우는 다음과 같습니다.
  - 입력을 읽는 작업을 다 끝내기 전에 결과를 얻어야 할 필요가 있는 경우
  - (중간 결과를 포함했을 때) 메모리 용량보다 더 큰 데이터를 처리해야 할 필요가 있는 경우
  - 파이프 라인 단계가 긴 큰 컬렉션의 경우 (이런 컬렉션에서는 중간 단계의 컬렉션을 만들어 내는 과정이 느릴 수 있습니다.)
  - 파이프라인 뒤쪽 단계 에서만 얻을 수 있는 정보를 활용해 파이프라인의 앞쪽 단계에서 원소 중 일부를 건너 뛸 수 있는 경우
- Iterable을 사용하기 적합한 경우는 다음과 같습니다.
  - 지연 계산이 필요없는 경우
  - 컬렉션이 작은 경우
  - 처음부터 코틀린으로 코드를 작성하는 경우(단순하고 일반적으로 더 빠르며 예상하기 쉬움)
  - 코틀린이 제공하는 더 풍부한 API의 이점을 누리기 위한 경우
- 시퀀스를 사용하기 적합한 경우는 다음과 같습니다.
  - 큰 컬렉션에 대해 너무 느리거나 메모리 사용량이 너무 많은 경우
- 만약, 시퀀스를 바꾸는 것 만으로 충분하지 않다면 스트림으로 바꿔서 병렬처리(parallelStream)을 사용할 수도 있습니다.

## 대수적 변환
- 우리가 스트림, 이터러블, 시퀀스를 사용하면서 원하는 것은 코드의 동작을 그대로 유지하면서 연산을 조작할 수 있는 규칙을 제공하는 코드를 만드는 것입니다.
  - 연산이 순서에 의존적이라면 스트림, 이터러블, 시퀀스를 오고가면서 문제가 생길 수 있습니다.
- 모든 연산이 계산일 경우 스트림이나 이터러블, 시퀀스와 같은 방법이 아닌 수학적인 계산을 통해 코드를 작성하면 훨씬 깔끔한 코드가 작성될 수도 있습니다.

    ```kotlin
    fun averageNonBlankLength(strings: Sequence<String>): Double =
    	strings.averageBy {
    		if (it.isBlank()) 0 else it.length
    	}
    ```
  
## 스트림에서 이터러블이나 시퀀스로 리팩터링하기
- 명시적 타입을 사용하면 어떤 타입인지 개발자가 바로 알 수 있고 컴파일 타입에 타입을 준수하도록 강제시킬 수 있습니다.
- 스트림을 이터러블이나 시퀀스로 마이그레이션 하면 확장함수, 코틀린 람다 구문, 개선된 타입 추론 등을 통해 코드를 좀 더 개선할 수 있습니다.
- 인메모리 컬렉션을 사용한다면 스트림보다는 이터러블이 효율적이고 깔끔한 작성을 할 수 있습니다. (상황에 따라 다르며, 이터러블이 적합하지 않을 경우 시퀀스를 사용하는 것을 추천합니다.)