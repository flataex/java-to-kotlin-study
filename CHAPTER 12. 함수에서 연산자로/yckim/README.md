# 함수에서 연산자로

## 토대가 되는 클래스
- 코틀린으로 한번에 전환할 수 있지만 토대가 되는 거대한 클래스의 경우 자바와 코틀린이 동시에 존재하는 애플리케이션이 만들어질 수 있습니다.
- 영리한 리팩터링 전술과 코틀린이 JVM 코드를 생성하는 방법을 제어하는 몇 가지 어노테이션을 사용하면 자바와 코틀린 양쪽의 좋은 점을 함께 취할 수 있습니다.
- 자바에서 코틀린으로 전환할때 서서히 전환하면서 코틀린의 결에 맞게 작성하는 것이 좋습니다.

## 사용자 정의 연산자 추가
- 코틀린에서는 연산자 오버로딩을 통해 다음과 같이 산술 연산자를 정의할 수 있습니다.

    ```kotlin
    
    val grossPrice = netPrice + netPrice * taxRate
    
    ```

  다음과 같이 정의할 수 있습니다.

    ```kotlin
    operator fun plus(that: Money): Money {
            require(currency == that.currency) {
                "cannot add Money values of different currencies"
            }
            return Money(amount.add(that.amount), currency)
        }
    ```

- 연산자 오버로딩시 이름이 정해져있지만 @JvmName을 이용하여 임의의 이름으로 변경할 수 있습니다.

    ```kotlin
    @JvmName("add")
    operator fun plus(that: Money): Money {
        require(currency == that.currency) {
            "cannot add Money values of different currencies"
        }
        return Money(amount.add(that.amount), currency)
    }
    ```

    - 단, 은 메서드가 한 코드 기반에서 위치에 따라 다른 이름으로 나타나면 상당히 혼란스러울 수 있으므로 팀원들 간의 충분한 인지와 합의가 필요합니다.
## 기존 코틀린 코드에서 정의된 연산자 호출하기
- 자바에서 사용하던 add 연산을 plus 연산을 호출하는 식으로 변경하면 하위호환성을 유지하면서 연산자 오버로딩을 사용하는 코드를 작성할 수 있습니다.
- add 연산을 사용하는 코드는 서서히 교체해가며 나중에는 모두 `+` 연산을 이용하도록 리팩토링 할 수 있습니다.
## 기존 자바 클래스를 위한 연산자
- 코틀린 표준 라이브러리에서는 자바 표준 라이브러리가 제공하는 클래스에 대한 연산자를 정의하는 확장 함수가 들어있습니다.
    - BigInteger, BigDecimal 등의 수학 클래스와 List<T>, Set<T> 등의 컬렉션이 포함됩니다.
## 값을 표현하는 관습
- 값을 표현하기 위해 사용하는 동반 객체에 선언한 정적 함수 들은 코틀린의 결에 맞지 않습니다.
- 코틀린 구문에서는 객체 생성과 함수 호출을 구분하지 않습니다.
- 코틀린은 동반 객체에 선언한 메서드보다 최상위 함수를 권장하는 경우가 많습니다.
- 자바와 JVM에는 내부 가시성이라는 개념이 없습니다.
    - 코틀린 클래스로부터 생성된 JVM 클래스 파일에서 내부 가시성은 코틀린 컴파일러가 인식하지만 자바 컴파일러가 무시하는 별도의 메타데이터로 저장됩니다.
    - 내부 가시성으로 선언된 코틀린 특성이 자바 컴파일러와 JVM에는 공개 가시성으로 보이며, 이로 인해 프로젝트에서 자바 코드로 작업을 할 때 실수로 잘못된 값을 생성하는 게 허용됩니다.
    - 이로인해 최상위 함수로 정적 팩토리 메서드 패턴은 부적절합니다.
- 동반객체에서 함수 호출 연산자를 정의하면 코틀린 코드는 직접 생성자를 호출하는 코드와 똑같은 문법을 사용해 객체를 생성할 수 있습니다.
    - 이 호출은 실제 생성자 호출은 아니며, kotlin의 invoke를 연산자를 이용해서 호출하는 것입니다.