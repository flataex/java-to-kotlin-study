# 소개

## 프로그래밍 언어의 결

프로그래밍 언어에도 결이라는 것이 존재하며 결을 따라 작성하면 코드가 간결해지는 효과를 받을 수 있습니다.

프로그래밍 언어의 결을 거스르면 다음과 같은 문제가 존재합니다.
- 원래 필요한 양보다 많은 코드를 작성합니다.
- 성능이 나빠질 수 있습니다.
- 실수를 하기 쉬워집니다.
- 제공되는 기능 대신 모든 기능을 직접 구현해야 합니다.

이와 같이 결을 거스르면 큰 노력을 해야하지만 그에 따른 결과는 보장할 수 없습니다.

## 자바 1.0에서의 결

자바 1.0에서는 함수형 스타일로 코드를 작성하는 프로그래머는 거의 없었습니다.

이는 자바 1.0에서는 함수형 프로그래밍을 하기에는 이른점이 있었습니다.

다음은 자바 1.0으로 함수형 프로그래밍을 하는 간단한 예제입니다.

### 자바 1.0에서 함수형 스타일로 배열 원소를 덧셈하는 기능 만들기

자바에는 일급시민인 함수가 존재하지 않았습니다.

```
💡 일급 시민이란 변수에 담을 수 있고 함수의 인자나 반환 값으로 
전달할 수 있는 것을 의미합니다.
```

예를 들어 덧셈 함수는 인자를 2개만 받기 때문에 인자가 2개인 함수를 나타내는 타입을 먼저 정의했어야 합니다.

```java
public interface BiFunction {
    Object apply(Object arg1, Object arg2);
}
```

이후 해당 함수를 받는 fold라는 고차함수를 작성해야 했습니다.
```java
public class Vectors {
	public static Object fold(Vector l, Object initial, BiFunction f) {
        Object result = initial;
        for (int i = 0; i < l.size(); i++) {
            result = f.apply(result, l.get(i));
        }
        return result;
    }
}
```
fold를 통해 Vector 클래스에 대해 필요한 `이터레이션과 상태변경을 감출수 있는 것`을 볼 수 있습니다.

그 다음 fold 함수에 넘기는 모든 함수에 대해 클래스를 따로 작성해야 합니다.

```java
public class AddIntegers implements BiFunction{
    @Override
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}
```

이제 만든 클래스들을 이용하면 합계를 구할 수 있게 됩니다.
```java
int sum = ((Integer) Vectors.fold(counts, new Integer(0), new AddIntegers()))
    .intValue();
```

코틀린으로 같은 기능을 하는 코드는 다음과 같습니다.
```kotlin
val sum = numbers.fold(0, Int::plus)
```

### 과거의 자바에서 함수형 프로그래밍을 하지 않은 이유
- 함수형 스타일을 적용하기 위해 많은 코드가 작성된다.
- 함수형 스타일로 작성한 여러 라이브러리를 조합하기 위해서는 추가적으로 어댑터 클래스를 작성해주어야 한다.
- JVM이 JIT을 제공하지 않고 단순한 가비지 컬렉팅만 하기 때문에 명령형으로 작성하는 것보다 느린 상황이 발생합니다.
  ```text
  💡JIT 컴파일러란, 실행 시점에 인터프리트 방식으로 기계어 코드를 생성하면서 
    그 코드를 캐싱하여 같은 함수가 여러번 불릴 때 매번 기계어 코드가 생기는 것을 방지하는 방식의 컴파일러입니다.
    
    자바 기준으로는 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음,
    실제 바이트 코드를 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환합니다.
    ```

결국 과거의 자바는 함수형 스타일을 적용하게 된다면 자바라는 프로그래밍 언어의 `결을 거스르게 되는 것`입니다.

## 자바의 진화
사람들이 자바로 작성한 코드들이 늘어나면서 공통적으로 이해한 내용을 바탕으로 다양한 라이브러리들이 생겨나고 노하우가 쌓여가면서 언어의 결이 자라나게 됩니다.

자바의 경우 시간이 지나면서 다음과 같은 변화가 생겨났습니다.
- 자바 1.1에서 익명 클래스가 추가 되었습니다.
- 자바 2에서 표준 라이브러리에 컬렉션 프레임워크가 추가 되었습니다.
- 자바 5에서 제네릭이 추가되었습니다.
- 자바 8에서 익명 함수와 메서드 참조가 추가되었고, 표준 라이브러리의 스트림 API가 추가되었습니다.

이제 각 자바 버전별로 함수형을 적용했을때 어떤 변화가 있었는지 확인해보겠습니다.

### 컬렉션과 익명클래스를 사용한 자바 코드의 변화
익명 클래스를 활용하면 따로 클래스에 이름을 붙이지 않아도 바로 구현 로직을 작성할 수 있습니다.
```java
int sum = ((Integer) Lists.fold(counts, new Integer(0), new BiFunction() {
    @Override
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}));
```
### 제네릭을 활용한 자바 코드의 변화
제네릭을 통해 타입 안전성이 좋아지고 오토박싱을 통해 불필요한 타입 캐스팅 코드를 줄일 수 있게 됩니다.
```java
int sum = Lists.fold(counts, 0, new BiFunction<Integer, Integer, Integer>() {
    @Override
    public Integer apply(Integer arg1, Integer arg2) {
        return arg1 + arg2;
    }
});
```
### 스트림을 활용하는 자바 코드의 변화
자바 8에서는 함수형 숙어를 사용하여 다음과 같이 간결하게 작성할 수 있습니다.
```java
int sum = counts.stream().reduce(0, Integer::sum);
```
## 자바에서의 함수형 스타일
자바 8에서 많은 변화가 생기면서 자바는 근본적으로 함수형 스타일을 사용할 수 있는 스타일의 언어로 변경되었습니다.

물론, 지금도 다음과 같은 부분이 자바에서 함수형 스타일을 적용하는데 아쉬움으로 존재합니다.
- 스트림 API는 일반적인 함수형 언어에서 찾아볼 수 있는 고차함수들이 빠져있습니다.
  - 고차 함수란 함수로 인자를 전달받거나 반환 값으로 함수를 전달하는 함수
- 체크 예외와 같은 개념은 함수형 프로그래밍과 잘 엮이지 않습니다.

## 정리
- 프로그래밍 언어들 마다 각자의 결이 있고 벗어난 방식으로 개발할 경우 여러 문제를 일으킬 수 있다.
- 처음 자바는 함수형 프로그래밍에 어울리지 않는 언어였지만 점차 언어가 진화하면서 함수형 프로그래밍을 적용할 수 있는 언어로 진화하였습니다.