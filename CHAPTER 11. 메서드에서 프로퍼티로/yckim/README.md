# 메서드에서 프로퍼티로

## 필드, 접근자, 프로퍼티
- 코틀린에서는 결과를 반환하는 함수보다 미리 계산된 프로퍼티를 더 선호해야 합니다.
- 대부분의 프로그래밍 언어는 데이터를 그룹으로 묶고 합성한 프로퍼티에 이름을 부여하는 방식을 제공합니다.

    ```kotlin
    class A {
    	private int a;
    }
    ```

- 초기의 객체지향은 단순히 레코드 필드에 불과하였고 메서드는 함수를 가리키는 포인터를 저장하는 필드였습니다.
- 자바 개발자들은 스몰토크 접근 방식을 가져와서 객체를 추상화하고 메세지를 이용하여 상태를 가져오거나 변경하도록 설계했습니다.
- 코틀린은 필드 직접 접근을 제공하지 않고 접근자 메서드만 제공합니다.
    - 코틀린은 자바 클래스에 공개 필드에 접근하는 코드를 생성하지만 코틀린 컴파일러가 공개 필드를 직접 정의하지는 않습니다.
    - 이런식으로 제공하는 이유는 클라이언트에 영향을 끼치지 않고 표현을 변경할 수 있도록 접근자 사용을 권장하기 때문입니다.
- 코틀린은 프로퍼티를 선언하면 접근자와 생성자를 자동으로 생성하게 됩니다.
- 계산된 프로퍼티를 사용하면 추가적으로 필드를 추가할 필요를 줄일 수 있습니다.
- 자바 객체의 프로퍼티를 코틀린에서 참조하면, 적절한 접근자가 존재하고 자바의 관습에 맞게 접근자 이름이 붙어 있는 경우에는 컴파일러가 접근자 호출문을 생성해 줍니다.
## 어떻게 선택해야 할까?
- 같은 타입에 속한 다른 프로퍼티에만 의존하고 계산 비용이 싼 경우에는 메서드 대신 계산된 프로퍼티를 선택하는 것이 좋습니다.
  - 동작인 함수의 경우 계산된 프로퍼티를 사용할 경우 시점에따라 계속 값이 바뀌므로 위험합니다.
  - 계산 비용이 큰 hash 같은 경우 계산된 프로퍼티로 사용하는 것은 부담이 될 수 있습니다.
    - 이경우 상황에 따라by lazy를 통해 호출시점 까지 초기화하지 않는 지연구문을 추가하여 프로퍼티로 사용해도 괜찮습니다.
    - 확장 프로퍼티의 경우 지연 프로퍼티를 사용할 수 없으므로 함수로 사용해야 합니다.
## 가변 프로퍼티
- 코틀린은 `var` 키워드를 통해 가변 프로퍼티를 선언할 수 있습니다.
- 데이터와 컬렉션은 불변으로 유지하는 것이 부수효과를 막을 수 있어 `var` 를 사용하는 것을 지양해야 합니다.
- 실전에는 대부분 복사 메서드가 있는 데이터 클래스가 데이터를 직접 설정하는 세터를 호출하는 것보다 더 잘 동작한다는 사실을 알게 됩니다.
## 프로퍼티로 리팩터링하기
- 기초 연산을 함수 안에 감추기보다는 찾아서 공개하는 것이 기능을 확장할 수 있어 더 좋습니다.
  ```kotlin
  // 기존코드
  fun CampSite.isIn(countryISO: String) =
  countryCode == countryISO && this.region.equals(region, ignoreCase = true)
  
  // 공개(when)
  fun CampSite.isIn(countryISO: String, region: String? = null) = when (region) {
  null -> countryCode == countryISO
  else -> countryCode == countryISO && region.equals(this.region, ignoreCase = true)
  }
  
  // 공개(엘비스 연산자)
  fun CampSite.isIn(countryISO: String, region: String? = null) =
  countryCode == countryISO &&
  region?.equals(this.region, ignoreCase = true) ?: true
  ```