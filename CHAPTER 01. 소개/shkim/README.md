# 프로그래밍 언어의 결

> 모든 프로그래밍 언어에는 결이 있다. <br>
> 프로그래밍 언어의 결을 거스르면 원래 필요한 양보다 코드를 더 많이 작성해야 하고, 성능이 나빠지고, 실수를 하기 쉽다.

<br>
<br>

<p>다음은 덧셈 연산자를 이용해 리스트를 접어서 리스트에 있는 모든 수의 합을 구하는 코틀린 코드이다</p>

```kt
val sum = numbers.fold(0, Int::plus)
```

<br>

<p>위 코드를 자바 8에서 구현한다면 아래와 같지만, 이 과정은 순탄치 않다</p>

```java
int sum = counts.stream().reduce(0, Integer::sum);
```

- 덧셈 연산자를 스트림의 reduce 함수에 전달할 수 없어서, 표준 라이브러리에서 같은 일을 하는 Integer::sum 함수를 이용한다.
- 자바의 타입은 기본형과 참조형을 구분하기에, 이상한 경우가 생길 수 있다. (ex.형변환으로 인한 비용 증가, etc..)
- 스트림에는 일반적인 함수형 언어에서 존재하는 공통 고차 함수가 없다. (기능이 적음)
- Checked Exception을 스트림과 엮기 쉽지 않다.
- 값처럼 쓰일 수 있는 불변 클래스를 만들려면 코드 작성을 많이 해야한다.


<br>
<hr>


# 코틀린의 결

> 코틀린에는 간결성, 안정성, 상호 운용성, 도구 친화성이라는 네 가지의 목표가 있다.

<br>

- 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 더 선호한다.
  - 데이터 클래스를 사용하여 DTO를 쉽게 생성

```kt
// getter(), setter(), equals(), hashCode(), toString(), copy(), componentN()를 컴파일시에 자동으로 생성
// var라면 getter(), setter()가 생기지만, val이라면 setter()는 생기지 않는다.
data class Person(
    var name: String, 
    var age: Int, 
    var gender: String
)
```

<br>

- 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.
  - 암시적인 타입 변환이 없다. (ex. 자바는 int를 long으로 암시적으로 변환해주지만, 코틀린에서는 Int.toLong()을 명시적으로 호출해야 함)

<br>

- 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호한다.
  - 타입 안전한, 합성적인 코딩 스타일을 장려한다.
  - 기본적으로 클래스는 확장될 수 없고, 메서드는 다형적이지 않다. 명시적으로 다형성과 상속을 활성화해야 한다.

<br>

- 코틀린은 특별한 경우를 좋아하지 않는다.
  - 자바와 달리 예측할 수 없는 방식으로 작동하는 특별한 경우가 적다.
  - 기본형과 참조형 사이의 구분이 없다.
  - void 타입의 함수도 없다.
    - 코틀린에선 void 대신 Unit/Nothing을 사용한다.
      - Unit은 리턴의 대상이 없을 뿐, 리턴이라는 행위를 안하는 것은 아니지만, Nothing은 리턴이라는 행위를 하지 않는다
      - 그래서 자바에서 void는 출력할 수 없지만, 코틀린에서는 Unit이라는 타입을 출력 가능.

<br>

- 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.
  - 자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 있다.
  - 자바와 코틀린 양쪽의 결을 모두 다룰 수 있어야 한다.
