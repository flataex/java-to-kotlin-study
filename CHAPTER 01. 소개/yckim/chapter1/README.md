# 프로그래밍 언어의 결

프로그래밍 언어에도 결이라는 것이 존재하며 결을 따라 작성하면 코드가 간결해지는 효과를 받을 수 있습니다.

프로그래밍 언어의 결을 거스르면 다음과 같은 문제가 존재합니다.
- 원래 필요한 양보다 많은 코드를 작성합니다.
- 성능이 나빠질 수 있습니다.
- 실수를 하기 쉬워집니다.
- 제공되는 기능 대신 모든 기능을 직접 구현해야 합니다.

이와 같이 결을 거스르면 큰 노력을 해야하지만 그에 따른 결과는 보장할 수 없습니다.

## 자바 1.0에서의 결

자바 1.0에서는 함수형 스타일로 코드를 작성하는 프로그래머는 거의 없었습니다.

이는 자바 1.0에서는 함수형 프로그래밍을 하기에는 이른점이 있었습니다.

다음은 자바 1.0으로 함수형 프로그래밍을 하는 간단한 예제입니다.

### 자바 1.0에서 함수형 스타일로 배열 원소를 덧셈하는 기능 만들기

자바에는 일급시민인 함수가 존재하지 않았습니다.

```
💡 일급 시민이란 변수에 담을 수 있고 함수의 인자나 반환 값으로 
전달할 수 있는 것을 의미합니다.
```

예를 들어 덧셈 함수는 인자를 2개만 받기 때문에 인자가 2개인 함수를 나타내는 타입을 먼저 정의했어야 합니다.

```java
public interface BiFunction {
    Object apply(Object arg1, Object arg2);
}
```

이후 해당 함수를 받는 fold라는 고차함수를 작성해야 했습니다.
```java
public class Vectors {
	public static Object fold(Vector l, Object initial, BiFunction f) {
        Object result = initial;
        for (int i = 0; i < l.size(); i++) {
            result = f.apply(result, l.get(i));
        }
        return result;
    }
}
```
fold를 통해 Vector 클래스에 대해 필요한 `이터레이션과 상태변경을 감출수 있는 것`을 볼 수 있습니다.

그 다음 fold 함수에 넘기는 모든 함수에 대해 클래스를 따로 작성해야 합니다.

```java
public class AddIntegers implements BiFunction{
    @Override
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}
```

이제 만든 클래스들을 이용하면 합계를 구할 수 있게 됩니다.
```java
int sum = ((Integer) Vectors.fold(counts, new Integer(0), new AddIntegers()))
    .intValue();
```

코틀린으로 같은 기능을 하는 코드는 다음과 같습니다.
```kotlin
val sum = numbers.fold(0, Int::plus)
```

### 과거의 자바에서 함수형 프로그래밍을 하지 않은 이유
- 함수형 스타일을 적용하기 위해 많은 코드가 작성된다.
- 함수형 스타일로 작성한 여러 라이브러리를 조합하기 위해서는 추가적으로 어댑터 클래스를 작성해주어야 한다.
- JVM이 JIT을 제공하지 않고 단순한 가비지 컬렉팅만 하기 때문에 명령형으로 작성하는 것보다 느린 상황이 발생합니다.
  ```text
  💡JIT 컴파일러란, 실행 시점에 인터프리트 방식으로 기계어 코드를 생성하면서 
    그 코드를 캐싱하여 같은 함수가 여러번 불릴 때 매번 기계어 코드가 생기는 것을 방지하는 방식의 컴파일러입니다.
    
    자바 기준으로는 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음,
    실제 바이트 코드를 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환합니다.
    ```

결국 과거의 자바는 함수형 스타일을 적용하게 된다면 자바라는 프로그래밍 언어의 `결을 거스르게 되는 것`입니다.

## 자바의 진화
사람들이 자바로 작성한 코드들이 늘어나면서 공통적으로 이해한 내용을 바탕으로 다양한 라이브러리들이 생겨나고 노하우가 쌓여가면서 언어의 결이 자라나게 됩니다.

자바의 경우 시간이 지나면서 다음과 같은 변화가 생겨났습니다.
- 자바 1.1에서 익명 클래스가 추가 되었습니다.
- 자바 2에서 표준 라이브러리에 컬렉션 프레임워크가 추가 되었습니다.
- 자바 5에서 제네릭이 추가되었습니다.
- 자바 8에서 익명 함수와 메서드 참조가 추가되었고, 표준 라이브러리의 스트림 API가 추가되었습니다.

이제 각 자바 버전별로 함수형을 적용했을때 어떤 변화가 있었는지 확인해보겠습니다.

### 컬렉션과 익명클래스를 사용한 자바 코드의 변화
익명 클래스를 활용하면 따로 클래스에 이름을 붙이지 않아도 바로 구현 로직을 작성할 수 있습니다.
```java
int sum = ((Integer) Lists.fold(counts, new Integer(0), new BiFunction() {
    @Override
    public Object apply(Object arg1, Object arg2) {
        int i1 = ((Integer) arg1).intValue();
        int i2 = ((Integer) arg2).intValue();
        return new Integer(i1 + i2);
    }
}));
```
### 제네릭을 활용한 자바 코드의 변화
제네릭을 통해 타입 안전성이 좋아지고 오토박싱을 통해 불필요한 타입 캐스팅 코드를 줄일 수 있게 됩니다.
```java
int sum = Lists.fold(counts, 0, new BiFunction<Integer, Integer, Integer>() {
    @Override
    public Integer apply(Integer arg1, Integer arg2) {
        return arg1 + arg2;
    }
});
```
### 스트림을 활용하는 자바 코드의 변화
자바 8에서는 함수형 숙어를 사용하여 다음과 같이 간결하게 작성할 수 있습니다.
```java
int sum = counts.stream().reduce(0, Integer::sum);
```
## 자바에서의 함수형 스타일
자바 8에서 많은 변화가 생기면서 자바는 근본적으로 함수형 스타일을 사용할 수 있는 스타일의 언어로 변경되었습니다.

물론, 지금도 다음과 같은 부분이 자바에서 함수형 스타일을 적용하는데 아쉬움으로 존재합니다.
- 스트림 API는 일반적인 함수형 언어에서 찾아볼 수 있는 고차함수들이 빠져있습니다.
  - 고차 함수란 함수로 인자를 전달받거나 반환 값으로 함수를 전달하는 함수
- 체크 예외와 같은 개념은 함수형 프로그래밍과 잘 엮이지 않습니다.

# 코틀린의 결
코틀린은 다음과 같은 목표를 가지고 있습니다.
- 간결성
- 안정성
- 표현력
- 상호 운용성
- 멀티 플랫폼

[참고](https://kotlinlang.org/#why-kotlin)

## 코틀린의 진화 방향
코틀린은 위와 같은 목표를 달성하기 위해 다음과 같은 방향으로 진화하고 있습니다.

### 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 선호합니다.
코틀린은 이를 위해 `데이터 클래스`를 사용하여 `값 의미론`을 제공하는 새로운 타입을 쉽게 정의할 수 있습니다.

```
💡 어떤 타입이 값 의미론(value semantics)을 제공한다는 말은 
  원시 타입 값처럼 스택에 데이터 구조가 할당되어 참조 타입의 객체에 따르는 부가비용이 들지 않으면서도, 
  일반 클래스가 제공하는 메서드 등의 편의 사항을 똑같이 사용할 수 있도록 해준다는 뜻입니다.
```

표준 라이브러리를 활용하면 루프를 돌면서 가변 데이터를 메모리에서 갱신하는 것보다 불변 데이터로 이뤄진 컬렉션의 변환을 훨씬 더 쉽고 간결하게 사용할 수 있습니다.
### 코틀린은 동작을 명시적으로 작성하는 쪽을 선호합니다.
코틀린은 암시적인 타입 변환이 없으며, 더 작은 데이터 타입을 큰 데이터 타입으로 자동으로 변환해주지도 않습니다.

자바는 정보 손실이 없으므로 int를 long으로 변환하는 것을 허용해주지만 코틀린에서는 Int.Long()을 `명시적으로 호출`해야 합니다.

명시성을 선호하는 경향은 흐름제어에서 더 잘 나타납니다.

코틀린은 자바와 달리 직접 작성한 타입에서 산술 연산이나 비교 연산을 오버로딩할 수 있지만 쇼트 서킷 연산자에 대한 오버로딩은 불가능합니다.

```
💡 쇼트서킷이란 논리 연산에서 두 피연산자 중 어느 한쪽만 “참”이면 우측 피연산자의 값은 평가하지 않고 바로 결과를 얻는 행위를 말합니다.
```

이런 연산자를 오버로드할 수 있게 허용하면 제어 흐름이 달라질 수 있기 때문입니다.
### 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호합니다.

코틀린은 타입 안전한, 합성적인 코딩 스타일을 장려합니다.

리플렉션을 사용하고 싶다면 플랫폼별로 다른 리플렉션 라이브러리를 의존관계에 추가해야하는 등 복잡합니다.

코틀린은 동적으로 코드를 분석해 프로그래머를 안내해주고, 코드 내비게이션을 자동화하며, 프로그램을 자동으로 변환해줄 수 있는 코틀린 언어를 잘 아는 IDE와 함께 사용하도록 만들어졌습니다.
### 코틀린은 특별한 경우를 좋아하지 않는다.
다음과 같이 자바와 달리 코틀린은 예측할 수 없는 방식으로 작동하는 경우가 적습니다.
- 원시 타입과 참조 타입 사이에 구분이 없습니다.
- 반환시 아무 값도 돌려주지 않는 함수에 대한 void 타입도 없습니다.
- 확장함수를 사용하면 기존 타입에 새로운 연산을 추가할 수 있고, 호출하는 쪽의 코드에서는 기존 연산과 확장함수를 구분할 수 없습니다.
  - 확장함수란 어떤 클래스의 멤버 메서드인 것 처럼 호출할 수 있지만 그 클래스 밖에 선언된 함수를 의미합니다.
- 인라인 함수를 사용해 새로운 제어 구조를 작성할 수도 있습니다.

### 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깹니다.
코틀린은 자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 들어있습니다.

이런 기능 중 일부는 타입 검사기가 보장하는 안전성을 없애기 때문에 기존 자바 코드와 함께 사용해야 합니다.

예를 들어 `lateinit`은 타입 시스템에 구멍을 만들기 때문에 객체를 리플렉션을 통해 초기화하는 자바 의존관계 주입 프레임워크의 컴파일러가 일반적으로 강제하는 캡슐화 경계를 간단히 무시하고 값을 주입할 수 있습니다.

```text
lateinit은 바로 초기화하지 않고 필요할때 초기화해서 사용하기위해 사용하는 키워드입니다.
```

## 코틀린 같은 자바코드 작성을 조심하자

자바를 사용하던 상태에서 코틀린을 처음사용하게 되면 코틀린 문법을 사용하는 자바코드를 작성하기 쉽습니다.

예를 들어 다음과 같이 작성하기 쉽습니다.
- 쓸데없는 보일러 플레이트 코드를 작성하게 된다.
- 코틀린의 표준 라이브러리를 잘 활용하지 못하게 된다.
- 타입 검사가 널 안전성을 강제하는 기능을 활용하지 못해서 널을 무조건 피하게 된다.

자연스럽게 코틀린을 사용하는 길은 자바 코드를 사용해야 하는 상황때문에 더 복잡해지게 될 수 있습니다.

실전에는 단순히 코틀린을 배우는 것 만으로는 충분하지 않고 자바와 코틀린 양쪽의 서로 다른결을 이해하고 잘 다룰 수 있도록 충분한 이해가 필요합니다.

# 코틀린으로 리팩터링 하기

## 자바 → 코틀린으로의 변환은 생각보다 쉽지 않다.

자바에서 코틀린으로 변경할 때는 다음과 같은 사항을 만족하며 리팩터링을 해야 합니다.
- 비즈니스 요구사항을 만족하도록 변경하며, 시스템에 문제가 없도록 코틀린과 자바를 혼용하는 코드 기반을 유지해야한다.
- 최대한 변화를 작게 수행하면서 각 변화를 이해하기 쉽고 무언가 잘못 됐을 때 원상 복구 하기 쉽도록 작성해야 한다.

리팩터링 과정은 다음과 같이 진행하는 것이 좋습니다.
1. 자바스러운 설계를 단순히 코틀린으로 구현해보기
2. 점진적으로 코틀린 언어의 기능을 적용해 합성하기 쉬운 구조의 코드를 만들기

리팩터링을 진행할 때는 한번에 변경하는 것이 아닌 점진적으로 개선해나가야 안전하게 리팩터링을 할 수 있습니다.

## 서로 다른 언어간의 리팩터링은 한 언어의 리팩터링 보다 어렵다.
리팩터링 도구가 서로 다른 언어간에서 제대로 작동하지 않을 수 있기 때문입니다.

이 때문에 리팩터링 시 수동으로 이루어져야 하기 때문에 시간도 더 오래걸리고 큰 위험 부담을 수반합니다.
## 단, 자바와 코틀린은 다른 언어들보다는 쉽다.
자바와 코틀린의 리팩터링은 다음과 같은 이유 때문에 다른 언어들보다 쉽게 진행할 수 있습니다.
- JVM 기반으로 동작하는 코틀린 언어의 설계
- 개발 도구에 대한 JetBrain의 투자

자바에서 코틀린으로 리팩터링 하는 과정은 다른 언어들에 비해 생산성을 해치지 않지만 코틀린으로 리팩터링이 진행될 수록 생산성이 향상된다는 장점이 있습니다.

## 리팩터링 원칙

마틴 파울러의 리팩터링이라는 책 이후 오랜 시간이 지나면서 IDE가 어느정도의 리팩터링 기능들은 자동으로 처리해주도록 변경되었습니다.

따라서, 우리는 자동 리팩토링을 사용해서 코드를 변환하되, 변환된 결과가 하나만 변환하면 자동 리팩터링이 그 변경을 잡아내서 원하는 최종 결과로 코드를 변경할 수 있는 형태로 코드를 작성해야 합니다.

### 테스트 커버리지가 좋다고 가정한다.

마틴 파울러는 "리팩터링을 하고 싶다면 필수 전제조건은 탄탄한 테스트가 있어야 한다." 라고 말했습니다.

좋은 테스트 커버리지는 우리가 설계 개선을 위해 수행하는 리팩터링이 시스템의 동작을 우연히 변경하는 일이 없을을 보장해줍니다.

만약, 시스템에 테스트 코드가 없는 상태에서 리팩터링을 진행한다면 "레거시 코드 활용 전략 : 손대기 두려운 낡은 코드, 안전한 변경과 테스트 기법"을 추천합니다.

### 항상 최소한으로 커밋한다.
변경 내용이 사소하더라도 항상 커밋한다고 가정할 때 `git bisect` 명령을 사용하여 테스트가 실패하는 첫번째 커밋을 보여줄 수 있습니다.

커밋이 이력이 크다면 `git bisect`가 그렇게 도움이 되지 않겠지만 최소한의 단위로 커밋한다면 오류를 일으키는 변경사항을 쉽게 되돌릴 수 있습니다.

# 정리
- 프로그래밍 언어들 마다 각자의 결이 있고 벗어난 방식으로 개발할 경우 여러 문제를 일으킬 수 있다.
- 처음 자바는 함수형 프로그래밍에 어울리지 않는 언어였지만 점차 언어가 진화하면서 함수형 프로그래밍을 적용할 수 있는 언어로 진화하였습니다.
- 코틀린은 간결성, 안전성, 표현력, 상호 운용성, 멀티 플랫폼과 같은 목표를 가지고 있습니다.
- 코틀린은 다음과 같은 방향을 목표로 진화하고 있습니다.
  - 코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 더 선호한다.
  - 코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.
  - 코틀린은 동적 바인딩보다 정적 바인딩을 더 선호합니다.
  - 코틀린은 특별한 경우를 좋아하지 않는다.
  - 코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.
- 개발자는 코틀린의 결에 맞게 작성하도록 노력해야 합니다.
- 리팩터링을 할때 한번에 변경하지말고 점진적으로 조금씩 변경해야 합니다.
  - 리팩터링을 할 때는 테스트 커버리지가 좋은 상태에서 진행해야 변경에 대해 예측할 수 있습니다.
  - 변경사항이 발생할 때 사소하더라도 작은 단위로 커밋하는 것이 좋습니다. 