# 캡슐화한 컬렉션에서 타입 별명으로

## 도메인 컬렉션 합성하기
- 자바 컬렉션 인터페이스는 가변적이지만 코틀린은 컬렉션을 값 타입으로써 다룹니다.
- 공유된 컬렉션을 변경할 경우 여러가지 문제가 발생할 수 있습니다.
    - 특히, 자바에서는 add와 set 메서드와 같이 상태를 변경하는 메서드들을 통해 쉽게 변경할 수 있습니다.
    - 이러한 문제 때문에 대부분의 자바 코드는 컬렉션을 캡슐화하여 외부에 공개하지 않는 방식을 사용합니다.
- 공유되는 리스트의 경우 완전히 캡슐화하기 위해 방어적 복사를 통해 값을 저장할 수 있습니다.
    - 단 이 경우 추가적인 비용이 발생하기 때문에 리스트의 수정이 일어나지 않는 구조라면 방어적 복사를 꼭 해야하는 것은 아닙니다.
- 캡슐화한 컬렉션 데이터를 처리하고 싶다면, 저항이 가장 적은 방법은 캡슐화한 클래스 안에 메서드를 추가하면 됩니다.
    - 이 경우 클래스가 애플리케이션의 다른 부분과 결합된 정도가 커지게 됩니다.

    ```java
    public void render(Iterable<Journey> route) {
            for (var journey : route) {
                render(journey);
            }
        }
    ```

- 다른 클래스 경계 안쪽에 도메인 모델의 데이터 구조를 감추는 대신에 도메인 모델이 적절한 데이터 구조가 되도록 한다면, 도메인 데이터에 사용할 수 있는 연산의 종류가 확장됩니다.
    - 예를 들어 Route 클래스가 모든 경로 기능을 제공하고 그에 따라 애플리케이션의 모든 부분을 서로 결합시키는 대신 각 경로 기능을 확장 함수로 임포트해서 합성할 수 있는 연산으로 바라볼 수 있습니다.
    - 자바는 정적 함수의 발견 가능성이 낮다는 점과 표준 라이브러리가 가변 컬렉션을 제공한다는 점을 보면 이러한 방식은 어울리지 않습니다.
    - 코틀린은  정적함수를 좀 더 쉽게 발견할 수 있게 도와주는 확장함수와 불변 컬렉션을 제공하기 때문에 도메인 모델을 컬렉션 타입으로 나누고 연산을 도메인 모델과 분리하는 쪽이 더 편리합니다.
- 타입별명을 통해 클래스를 대체할 수 있습니다.

## 다른 프로퍼티가 있는 컬렉션
- 항상 타입별명이 클래스를 대신할 수는 없습니다.
- 다른 프로퍼티가 존재할 경우 내부에 있는 컬렉션으로 치환할 수 없습니다.
    - 이런 경우 내부에 있는 컬렉션을 인터페이스로 구현하면 캡슐화되지 않은 컬렉션의 장점을 취할 수 있습니다.

## 캡슐화된 컬렉션 리팩터링 하기
- 코틀린에서 연산들을 확장함수로 변환하면 하나의 클래스가 너무 많은 기능을 포함하지 않을 수 있습니다.
    - 확장함수로 변환하면 연산들을 다른 파일로 이동하거나 결합을 줄이기 위해 다른 모듈로 이동시킬수도 있습니다.
- 클래스로 감싸서 기능을 사용하면 생성하고 변환하고 처리하면 코틀린 표준 라이브러리가 제공하는 기능을 사용할 수 없기 때문에 권장하지 않는다.
- 타입 별명을 이용하여 클래스를 변환하면 해당 클래스를 특정 타입인 것 처럼 사용할 수 있습니다.

    ```kotlin
    // 변환전
    class Route(
    	val journeys: List<Journey>
    ) : List<Journey> by journeys
    val Route.size: Int get() = this.size
    
    // java
    route.size()
    // kotlin
    route.size()
    
    // 변환 후
    typealias Route = List<Journey>
    
    // java
    route.size()
    // kotlin
    route.size
    ```

    - 클래스를 사용하는 경우 List의 기능들을 사용할 수 없지만 코틀린의 타입별명을 이용하여 작성하게 되면 List에서 제공하는 기능들을 쉽게 사용할 수 있습니다.
- 만약, 클래스에 프로퍼티가 여러개라면 위임과 데이터 클래스를 이용하여 코틀린 타입 시스템에 의존하도록 작성할 수 있습니다.

## 정리

- 자바에서는 값 의미를 지원하기 위해 가변 컬렉션을 캡슐화하는 클래스를 많이 만들었습니다.
- 코틀린에서는 컬렉션 방지를 위해 코틀린 타입 시스템에 더 많이 의존할 수 있게 되었고, 더 이상 컬렉션을 클래스 안에 캡슐화할 필요가 없어졌습니다.
    - 클래스 안에 캡슐화를 진행하지 않으면서 클래스의 메서드들을 확장함수로 옮기고 확장함수 들을 사용하는 장소에 가깝게 옮길 수 있습니다.
- 하나의 컬렉션만 캡슐화하는 경우 클래스 자체를 없애고 타입 별명으로 대신할 수 있습니다.
- 불변 클래스와 확장을 사용하면 자바에서는 사용할 수 없는 방식으로 코드를 조직할 수 있습니다.
    - 애플리케이션의 특정 기능에 필요한 모든 로직을 그 로직이 적용되는 도메인 클래스와 별도로 하나로 묶어서 한 모듈안에 넣을 수 있습니다.
    - 하지만 이런 도메인 클래스의 메서드가 다형적인 메서드가 되어야 한다면, 기능 로직을 특성 모듈이 아니라 도메인 클래스 안에 정의해야 합니다.
        - 이는 차후에 학습할 봉인된 클래스를 통해 처리할 수 있습니다
- 구체적 타입 대신 List 같은 내장 타입을 재사용하는 것이 아무런 비용이 들지 않는 것은 아닙니다.
    - 캡슐화한 클래스를 사용하는 것이 코드를 위치를 찾는 것이 더 편하고 특정 기능을 감추려고 할때 더 적합합니다.